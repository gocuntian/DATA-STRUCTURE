## 数据结构之链表

### 一、基本概念

链表和数组的唯一区别在于存储空间的不连续性

这里解释一下为什么数组可以通过下标引用的方式（如 A[i]）随机访问数组中的数据。

我们知道，数组在内存中占用一段连续的存储空间，我们通过下标引用数组中的元素的时候，计算机通过数组的首地址和偏移量计算出我们需要引用的数据的实际存储地址，这就实现了随机访问，随机访问一个数据的时间复杂度为 o(1)

链表中的每个数据存储单元是不连续的，要访问链表中第 i 个数据，我们只能通过从链表的头部往后遍历到第 i 个数据存储单元的方式访问该数据，访问一个数据的时间复杂度视要访问的数据在链表中的位置决定，一般的，我们笼统的认为访问一个数据的时间复杂度是 o(n) 的，其中 n 是链表的长度，这个时间复杂度是最坏时间复杂度

### 二、链表的种类介绍

首先我们给出一些术语说明

+ **前驱**：节点 u 是 v 的前驱指的是 u 到链表头的距离等于 v 到链表头的距离加一
+ **后继**：节点 v 是 u 的后继指的是 u 到链表头的距离等于 v 到链表头的距离加一

#### 单链表

每个节点只有一个指针域，指向它的后继节点

链表尾的后继指针为 null

这种链表只能通过表头遍历到表尾

#### 双向链表

每个节点有两个指针域，一个指向它的前驱，一个指向它的后继

链表头的前驱指针为 null，链表尾的后继指针为 null

这种链表能通过表头遍历到表尾，也能通过表尾遍历到表头

#### 单向循环链表

在单链表的基础上，链表尾节点的后继指针指向链表头节点，整个链表构成了一个环

#### 双向循环链表

在双向链表的基础上，链表尾节点的后继指针指向链表头节点，连表头节点的前驱指针指向链表尾节点

### 三、链表的操作

#### 判断链表是否为空

这个操作根据实现链表的方式不同有着不同的方法，不过时间复杂度都是 o(1)

#### 在链表中某个节点后面插入一个数据

+ 输入参数1：链表中某个节点的地址
+ 输入参数2：待插入数据

时间复杂度：O(1)

#### 遍历链表所有元素

根据链表类型的不同，有着不同的实现方式，一种常用的做法是从链表头沿着后继指针遍历到链表尾

需要注意的是循环链表判断到达链表尾

#### 合并两个链表

这种操作常用在归并排序中，待合并的两个链表中的数据都是按照某种顺序（“从小到大”等等）排列，要求合并之后的链表仍然保持这种顺序

时间复杂度：O(n+m)，其中 n 和 m 分别是两个链表的长度

#### 交换链表中两个节点

这种操作通常用在各种排序算法中，交换两个链表以达到使链表中的数据有序的目的

注意：由于单链表的交换我们需要知道待交换的两个节点各自的前驱节点，因此这种操作通常用于双向链表中

时间复杂度：o(1)

#### 读取链表中第 i 个数据

这种操作是最常见的，最坏时间复杂度 o(n)，其中 n 指链表长度

#### 删除链表中指定的节点

+ 输入参数：待删除节点地址

*注意：如果是单链表，我们还需要另一个输入参数 —— 待删除节点的前驱节点*

时间复杂度：o(1)

----------

以上所有关于链表的操作，最关键最细节的还是链表的前驱指针和后继指针的处理。写代码前想好了再写