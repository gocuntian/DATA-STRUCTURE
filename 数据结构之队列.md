##	数据结构之队列

### 一、基本概念

**队列（queue）**有两个端口：队头（front）和队尾（rear），只允许在队尾插入数据，在队头读取和删除数据，因此最先进入队列的数据最先被删除，这种特性我们称之为 **先进先出（First In First Out, FIFO）**

队列在生活中最常见的一个例子就是排队打饭（这里仅考虑最理想情况：没人插队），最先排队的总是最先打到饭，可供选择的菜品也最多，排到最后的就只能吃点残羹冷炙了

###	二、队列的实现

在实际应用中，可以使用数组或者链表实现队列，下面的分析中，我们使用数组实现队列

###	三、使用数组实现队列

队列的实现方式多种多样，即使使用数组，在具体实现细节上也有很多不同的地方，这里，我们假设队头指针 **front** 指向队列中第一个元素，队尾指针 **rear** 指向队列最后一个元素的下一个未被使用的位置，如下图所示：

![](http://i.imgur.com/gTNlfDF.png)

#### 用一个结构体表示队列
```C
typedef struct {
    int size;
    int *data;
    int front;
    int rear;
} queue_type;
```
#### 函数一：判断队列是否为空

判断依据：front 是否等于 rear

#### 函数二：判断队列是否已满

判断依据：队尾指针 rear 是否等于队列的 size

#### 函数三：插入操作
小细节：在进行插入操作时，需要考虑插入前队列是否已满

+ 将待插入数据存入 data[rear]
+ rear 自增 1，指向下一个未被使用的位置

#### 函数四：读取队头元素

注意：这一个函数仅仅是读取队头不删除，需要判断队列是否为空

+ 输出 data[front] 中的元素

#### 函数五：删除操作

小细节：在进行删除操作时，需要考虑删除前队列是否为空

+ front 自增 1，指向队列中下一个元素

### 四、循环队列

我们看看数组的使用情况

+ 下标区间在 [0, front-1] 的位置是没有被队列使用的
+ 下标区间在 [rear, size-1] 的位置是没有被队列使用的

换句话说，数组中唯一被队列使用的区间是 [front, rear-1]，这极大的浪费了我们的内存。实际上，每从队列中删除一个数据，队列的最大容量就减一；每往队列中添加一个数据，队列可供使用的容量就减一，甚至可能出现下面的情况：

![](http://i.imgur.com/djwkLtv.png)

这种情况，队列中只有一个数据，但是队列已经满了，数组的使用率极其低下（1/7），如何改善呢？



**把数组的头和尾拼接起来，形成一个环**

上图中的情形就可转换为下图，从而极大的提高数组的使用率：

![](http://i.imgur.com/RogPvSV.png)

#### 判断循环队列是否为空

我们还是使用判断 rear 是否等于 front 的方法判断队列是否为空

#### 判断循环队列是否已满

这里需要注意了，当 (rear + 1) % size == front 的时候，我们认为队列已满，满足这个公式的一个例子如下：

![](http://i.imgur.com/pGu5kVs.png)

#### 其他操作

循环队列的其他操作：**插入数据**，**读取队头**，**删除数据**的过程和一般队列相似，不过在队头指针 front 和队尾指针 rear 自增的时候需要注意取 size 的模
